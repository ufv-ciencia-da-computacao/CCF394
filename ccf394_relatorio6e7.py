# -*- coding: utf-8 -*-
"""CCF394-Relatorio6e7.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/178OZ420yUv5YfIyqsDZvwCZxHALfr9UI
"""

import numpy as np
import cv2
from google.colab.patches import cv2_imshow
import matplotlib.pyplot as plt
import pandas as pd
from sklearn import svm
from sklearn.model_selection import train_test_split
from sklearn.metrics import confusion_matrix
from sklearn.utils.multiclass import unique_labels
import matplotlib.pyplot as plt
from sklearn.metrics import accuracy_score

"""# Relatório das aulas 6 e 7

Grupo
* Germano Barcelos dos Santos (3873)
* Guilherme Corrêa Melos (3882)
* Jhonata Miranda da Costa (3859)

## Introdução

A utilizacão de algoritmos de clusterização e de classificação é de suma importância para o entendimento de dados, o primeiro destaca-se pelo extração de dados de uma amostra, agrupando estes em clusteres, que representam características semelhantes entre dados (como por exemplo, a distância euclidiana em relacão a um centróide aleatoriamente escolhido), dado um número de grupos e o segundo refere-se a classificação de uma amostragem de dados em grupos.

No contexto de Processamento Digital de Imagens, como viremos a seguir, será utilizado uma imagem que representa uma parcela da Floresta Amazônica que se encontra em desmatamento e a mesma região desmatada alguns períodos após a captura da imagem, queremos observar a evolução do desmatamento através da utilização do algoritmo de clusterização K-means e classificar uma amostragem desta mesma imagem já clusterizada utilizando o algoritmo de classifição Support Vector Machine.

## Desenvolvimento

### Exercício 1

O exercício consiste na utilização do método K-means na imagem desmatamento.png, que consiste em duas coletas em períodos distintos de uma mesma região onde ocorre desmatamento na Amazônia, para obter imagens resultantes em falsa-cor.
"""

img = cv2.imread('desmatamento.png')

Z = img.reshape((-1,3))
Z = np.float32(Z)

criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 10, 1.0)

for K in range(2, 6):
  ret,label,center=cv2.kmeans(Z,K,None,criteria,10,cv2.KMEANS_RANDOM_CENTERS)
  center = np.uint8(center)
  res = center[label.flatten()]
  res2 = res.reshape((img.shape))
  final=np.concatenate((img,res2),axis=1)
  cv2_imshow(final)
  filename = "K-means "+ str(K)+".png"
  cv2.imwrite(filename,res2)
  num=center.shape[0]
  k=np.ones((10,100,100,3),np.uint8)
  for j in range(0,num):
    print("Centro do cluster %d:"%j)
    print(center[j])

  k1= np.ones((100,100,3),np.uint8)
  k2=np.ones((100,100,3),np.uint8)
  k3=np.ones((100,100,3),np.uint8)
  for j in range(0,num):
    k[j,:,:,0]=[center[j][0]]
    k[j,:,:,1]=[center[j][1]]
    k[j,:,:,2]=[center[j][2]]

  final=np.concatenate((k[0],k[1],k[2],k[3],k[4]),axis=1)

  cv2_imshow(final)
  cv2.waitKey(0)

cv2.destroyAllWindows()

"""Pudemos observar através da execucão do K-means com 10 iteraçōes e com uma precisão de erro absoluta menor que 1. Pudemos observar visualmente que o algoritmo classifica a segunda imagem como contendo uma área com maior desmatamento.

Conforme o número de clusteres aumenta, pudemos também notar que as tonalidades dos tons mais fortes para os tons mais neutros indicam a intensidade do desmatamento retratado na imagem. Como por exemplo, para K = 5, o centroide 3 BGR(18, 37, 37) indica que a área é não afetada pelo desmatamento, enquanto o centróide BGR(166, 205, 236) representa uma área desmatada e os tons "intermediários" representam zonas de risco, utilizando esta mesma escala.

### Exercicio 2

Para o exercício, foi selecionado a classificação utilizando o K-means do exercício anterior com K = 5, a seguir foi utilizado o ROI Picker localmente na máquina para pegar uma amostragem da imagem, coletando um total de 1971 amostras de pixel. Entretanto, o número de clusteres é grande e apresenta detalhes mais diversos sobre o desmatamento da Amazônia, sendo assim queremos testar a eficiência do algoritmo de classificação SVM com kernels Linear e RBF.
"""

classe=0
def on_mouse(event, x, y, flags, param):
    if event == cv2.EVENT_LBUTTONDOWN:
        global pixels
        (B,G,R)=img[y,x]
        print ("col: %d, row: %d   - R= %d, G=%d, B=%d" % (x, y, R,G,B))
        p=np.array([[B,G,R,classe]])
        print(x)
        pixels=np.concatenate((pixels,p))
        (B,G,R)=img[y,x+1]
        p=np.array([[B,G,R,classe]])
        pixels=np.concatenate((pixels,p))
        (B,G,R)=img[y+1,x]
        p=np.array([[B,G,R,classe]])
        pixels=np.concatenate((pixels,p))
         
        (B,G,R)=img[y+1,x+1]
        p=np.array([[B,G,R,classe]])
        pixels=np.concatenate((pixels,p))

"""Utilizamos o script abaixo para coleta de dados das 5 classes na imagem classificada pelo K-means com 5 clusters. 

**OBS: Não execute o código no Notebook abaixo pois, devido a problemas de kernel, o mesmo não é executável via Jupyter Notebook. Executamos o Script em python, fizemos a coleta dos dados e salvamos no arquivo dados.csv!!!!!!!!**

```
arquivo="dados.csv"
   
numClasses=int(input("entre com o numero de classes para coletas pixels: "))
for j in range(0, numClasses):
    print("Coletando para o agrupamento %d " % j)
    pixels =np.zeros((1,4),dtype=np.int8)
    print(pixels)
    img=cv2.imread("/content/K-means 5.png")
    cv2.namedWindow('frame1')
    cv2.setMouseCallback("frame1", on_mouse)
    CONTADOR=0
    while True:
        cv2_imshow(img)
        key = cv2.waitKey(1) & 0xFF
        if key == ord("c"):
            with open(arquivo, 'a') as f:
                f.write("\n")
            break
    classe=classe+1
    pixels = pixels[1:]
    media=np.mean(pixels,axis=0)
    mediaB=media[0]
    mediaG=media[1]
    mediaR=media[2]
    print("Media R=%d, media G= %d, media B=%d \n " % (mediaR, mediaG, mediaB))
    rows,cols,cor = img.shape
    csv_rows = (["{},{},{},{}".format(i, j, k,l) for i, j, k,l in pixels])
    linha=None
    csv_text = "\n".join(csv_rows)
    with open(arquivo, 'a') as f:
        f.write(csv_text)
f.close()
cv2.destroyAllWindows()
```
"""

def plot_confusion_matrix(y_true, y_pred, classes,
                          normalize=False,
                          title=None,
                          cmap=plt.cm.Blues):
   
    if not title:
        if normalize:
            title = 'Matriz de Confusão normalizada'
        else:
            title = 'Matriz de Confusão NÃO normalizada'

    # calcula  a matriz de confusão
    cm = confusion_matrix(y_true, y_pred)
    
    classes = classes[unique_labels(y_true, y_pred)]
    if normalize:
        cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]
        print("Matriz de Confusão normalizada")
    else:
        print('Matriz de Confusão NÃO normalizada')

    print(cm)

    fig, ax = plt.subplots()
    im = ax.imshow(cm, interpolation='nearest', cmap=cmap)
    ax.figure.colorbar(im, ax=ax)

    ax.set(xticks=np.arange(cm.shape[1]),
           yticks=np.arange(cm.shape[0]),
           # ...criando os labels
           xticklabels=classes, yticklabels=classes,
           title=title,
           ylabel='Entrada',
           xlabel='Saida')

    # rotacionando os labels
    plt.setp(ax.get_xticklabels(), rotation=45, ha="right",
             rotation_mode="anchor")

    # Percorrendo sobre os dados e criando as anotações de texto
    fmt = '.2f' if normalize else 'd'
    thresh = cm.max() / 2.
    for i in range(cm.shape[0]):
        for j in range(cm.shape[1]):
            ax.text(j, i, format(cm[i, j], fmt),ha="center", va="center",color="white" if cm[i, j] > thresh else "black")
    fig.tight_layout()
    return ax

print("Script que le o arquivo dados.csv gerado pelo  CCF394 roi picker de imagens")
print("E realiza a classificação dos pixels utilizando SVM")
print("aceita somente 5 classes, determinadas durante a captura dos pixels")

df = pd.read_csv('dados.csv')
df.head(2)

"""#### Kernel RBF"""

#selecionado os dados
X=df.iloc[:,[0,1,2]].values
Y=df.iloc[:,[3]].values

#criando o nome das 5 classes de saida
class_names = np.array(['Grupo1','Grupo2','Grupo3','Grupo4','Grupo5'])

#dividindo o pacote de dados em treino e teste
X_train, X_test, y_train, y_test = train_test_split(X, Y, random_state=0)

#criando o modelo do classificador e obtendo as saidas para as entradas de teste
classificador = svm.SVC(kernel='rbf', C=0.01)
y_pred = classificador.fit(X_train, y_train).predict(X_test)

#convertendo para array, para aplicar na matriz de confusão
y_test=np.array(y_test)
y_pred=np.array(y_pred)

np.set_printoptions(precision=2)
#plot_decision_regions(X, Y, classifier=classificador)
#plt.legend(loc='upper left')
#plt.tight_layout()
#plt.show()

# Plot non-normalized confusion matrix
plot_confusion_matrix(y_test, y_pred, classes=class_names, title='Matriz de Confusão')

# Plot normalized confusion matrix
plot_confusion_matrix(y_test, y_pred, classes=class_names , normalize=True,
                      title='Normalized confusion matrix')

precisao=100*accuracy_score(y_test,y_pred)
print(f'Precisão do modelo: {precisao:.3f} %')
print(" Aguarde a classificação dos pixels...")

newImage = cv2.imread("/content/K-means 5.png")
rows,cols,cor = newImage.shape
for y in range(0,rows):
    for x in range(0,cols):
        entrada=newImage[y,x]
        Saida=classificador.predict(entrada.reshape(1,-1))
        if Saida==0:
            newImage[y,x]=(0,0,255)
        if Saida==1:
            newImage[y,x]=(255,0,0)
        if Saida==2:
            newImage[y,x]=(0,255,0)
        if Saida==3:
            newImage[y,x]=(255,255,255)
        if Saida==4:
            newImage[y,x]=(100,100,100)
cv2_imshow(newImage)
filename = "desmatamentoSegmentado.png"
cv2.imwrite(filename,newImage)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""A classificação utilizando o algoritmo SVM com kernel RBF obteve uma precisão de 69.574%, sendo que para os clusteres 4 e 5 o modelo errou todos pontos classificados, uma hipótese é que as tonalidades de verde sejam muito próximas entre si e devido ao número de clusteres, algumas tonalidades da classificação do k-means possuam poucos pixels, tornando improvável a captura de uma quantidade significativa de pixels para cada tonalidade durante a amostragem.

#### Kernel Linear
"""

#selecionado os dados
X=df.iloc[:,[0,1,2]].values
Y=df.iloc[:,[3]].values

#criando o nome das 5 classes de saida
class_names = np.array(['Grupo1','Grupo2','Grupo3','Grupo4','Grupo5'])

#dividindo o pacote de dados em treino e teste
X_train, X_test, y_train, y_test = train_test_split(X, Y, random_state=0)

#criando o modelo do classificador e obtendo as saidas para as entradas de teste
classificador = svm.SVC(kernel='linear', C=0.01)
y_pred = classificador.fit(X_train, y_train).predict(X_test)

#convertendo para array, para aplicar na matriz de confusão
y_test=np.array(y_test)
y_pred=np.array(y_pred)

np.set_printoptions(precision=2)
#plot_decision_regions(X, Y, classifier=classificador)
#plt.legend(loc='upper left')
#plt.tight_layout()
#plt.show()

# Plot non-normalized confusion matrix
plot_confusion_matrix(y_test, y_pred, classes=class_names, title='Matriz de Confusão')

# Plot normalized confusion matrix
plot_confusion_matrix(y_test, y_pred, classes=class_names , normalize=True,
                      title='Normalized confusion matrix')

precisao=100*accuracy_score(y_test,y_pred)
print(f'Precisão do modelo: {precisao:.3f} %')
print(" Aguarde a classificação dos pixels...")

newImage = cv2.imread("/content/K-means 5.png")
rows,cols,cor = newImage.shape
for y in range(0,rows):
    for x in range(0,cols):
        entrada=newImage[y,x]
        Saida=classificador.predict(entrada.reshape(1,-1))
        if Saida==0:
            newImage[y,x]=(0,0,255)
        if Saida==1:
            newImage[y,x]=(255,0,0)
        if Saida==2:
            newImage[y,x]=(0,255,0)
        if Saida==3:
            newImage[y,x]=(255,255,255)
        if Saida==4:
            newImage[y,x]=(100,100,100)
cv2_imshow(newImage)
filename = "desmatamentoSegmentado.png"
cv2.imwrite(filename,newImage)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""A classificação utilizando o algoritmo SVM com kernel Linear obteve uma precisão de 83.976%, sendo que para o cluster 5 o modelo errou todos pontos classificados, uma hipótese é que as tonalidades de verde sejam muito próximas entre si e devido ao número de clusteres, algumas tonalidades da classificação do k-means possuam poucos pixels, tornando improvável a captura de uma quantidade significativa de pixels para cada tonalidade durante a amostragem.

### Exercício 3

Neste exercício, utilizamos a imagem resultante da segmentação feita pelo SVM com kernel RBF do exercício anterior. Abaixo é carregada a imagem:
"""

imagem = cv2.imread("/content/desmatamentoSegmentado.png")

"""Aqui exibimos os dados da imagem e fazemos uma cópia:"""

imagem2=imagem.copy()
print('Tipo da Imagem :', imagem.dtype) #imprime tipo de dados da imagem
print('Tamanho em pixels da imagem: ', imagem.size)
print("linha = ",imagem.shape[0],"col= ",imagem.shape[1])

"""Por fim, percorrendo pixel a pixel, contamos quantos píxels foram coloridos de vermelho ou azul na imagem da esquerda, que representa o local 6 meses antes da imagem da direita. Fazemos a mesma contagem, das mesmas cores, na imagem da direita e calculamos a porcentagem de crescimento do desmatamento."""

quantpix_desmantamento_antes = 0
quantpix_desmantamento_depois = 0
[col,lin,dim] = imagem.shape
for i in range(0,270):
  for j in range(0,col-1):
    (b,g,r) = imagem[j,i]
    if ((r == 255) and(g == 0) and (b == 0)) or ((b == 255) and(g == 0) and (b == 0)):
      quantpix_desmantamento_antes += 1

for i in range(270,565):
  for j in range(0,col-1):
    (b,g,r) = imagem[j,i]
    if ((r == 255) and(g == 0) and (b == 0)) or ((b == 255) and(g == 0) and (b == 0)):
      quantpix_desmantamento_depois += 1

print((quantpix_desmantamento_depois/quantpix_desmantamento_antes)*100,"%")

"""Com esse exercício, podemos utilizar a imagem classificada para verificar a diferença de área desmatada no "antes e depois" apresentado.

## Conclusão

Em síntese, foi possível através do algoritmo K-means extrair a intensidade do desmatamento na região através da utilizacão de clusteres, tornando-se mais rico em detalhes conforme a quantidade de clusteres aumentava (sugere-se para que não exista um overfitting na quantidade de agrupamentos, a utilização de algum método que determine uma quantidade ótima de clusters, como o Elbow method). Entretanto, acredita-se para observar a evolução do desmatamento seria melhor a utilizacão do agrupamento com K=2, visto que podemos reduzir os agrupamentos em desmatados ou não-desmatados.

Para a utilizacão do algoritmo de classificação SVM, foi utilizada uma amostragem de 1971 pixels, que representa aproximadamente 1.44% da quantidade total de pixels da imagem. Conseguimos classificar esta amostragem com precisão de 69.574% para o kernel RBF e 83.976% para o kernel linear. A proximidade entre as tonalidades dos clusteres para K=5 possuem um overfitting e algumas tonalidades não foram bem classificadas em decorrência disto, visto que não é necessário tamanha riqueza em detalhes para o agrupamento e nem para a classificação, a escolha foi feita para fins didáticos.
"""

!jupyter nbconvert --to pdf /content/CCF394_Relatorio6e7.ipynb

!zip -r /content

